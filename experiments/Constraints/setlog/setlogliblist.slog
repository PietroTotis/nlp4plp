%%% version 1.0-0

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      {log} standard library for dealing with lists (as sets)
%                           Version 1.0
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%           by Maximiliano Cristia' and  Gianfranco Rossi
%                           October 2019 
%
%    (requires {log} with RIS - setlog496-17i or newer) 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% These definitions follow the standard definitions given in
% the Z mathematical toolkit regarding lists (called sequences).
% See for example:
%
% Saaltink, M.: The Z/EVES mathematical toolkit version 2.2 for 
% Z/EVES version 1.5. Tech. rep., ORA Canada (1997)
%
% Spivey, J. M. The Z notation: a reference manual Prentice Hall
% International (UK) Ltd., 1992
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% slits(S): true if S is a set representing a list. This means
%%% that S is a partial function whose domain is equal to [1,n]
%%% for some natural n

slist(S) :- 
  pfun(S) & 
  dom(S,D) &
  size(D,N) &
  subset(D,int(1,N)).

%%% head(S,H): true if H is the first element of list S

head(S,H) :- slist(S) & [1,H] in S.

%%% last(S,L): true if L is the last element of list S

last(S,L) :- 
  pfun(S) & 
  dom(S,D) &
  size(D,N) &
  subset(D,int(1,N)) &
  [N,L] in S.

%%% add(S,E,T): true if T is the list obtained by appending E to the list S

add(S,E,T) :- 
  pfun(S) & 
  dom(S,D) &
  size(D,N) &
  subset(D,int(1,N)) &
  M is N + 1 &
  T = {[M,E] / S}.

%%% front(S,T): true if T is a list equal to list S minus its last element

front(S,T) :-
  S = {[N,_] / T} & 
  pfun(S) & 
  dom(S,D) &
  size(D,N) &
  subset(D,int(1,N)) &
  comp({[N,N]},T,{})
  or
  S = {} & T = {}.

%%% tail(S,T): true if T is a list equal to the tail os list S

tail(S,T) :-
  slist(S) &
  S = {[1,_] / U} & comp({[1,1]},U,{}) &
  T = ris([X,Y] in U, [K], true, [K,Y], K is X - 1)
  or
  S = {} & T = {}.

%%% concat(S,T,U): true if U is a list equal to the concatenation of
%%% lists S and T

concat(S,T,U) :-
  list(S) &
  list(T) &
  size(S,N) &
  un(S,ris([A,B] in T,[K],true,[K,B],K is A + N),U).


% List operators implemented with recursion
% Some of them (maybe all of them) can be written
% as {log} formulas but it needs to be extended


%%% filter(A,S,T): true if T is a list equal to S after removing from
%%% it the elements located in all the positions given by set A

% A is not constrained to be a set of integers
% however it can be done as follows
% A = ris(N in A, integer(N))
% or as follows
% subset(A,int(M,N))
% where M and N are the min and max limits of int
% I wouldn't be necessary because squash will
% forse them to be integers

filter(A,S,T) :- slist(S) & dres(A,S,R) & squash(R,T).


%%% extract(S,A,T): true if T is a list equal to S after removing from
%%% it the elements given by set A

extract(S,A,T) :- slist(S) & rres(S,A,R) & squash(R,T).


%%% squash(S,L): true if S is a set of ordered pairs whose first
%%% components are natural numbers >= 1, L is a list (set of
%%% orderd pairs) containing
%%% the elements Y, for all [X,Y] in S, and L is ordered according
%%% to the values of X (e.g., squash({[2,a],[7,b],[4,c]},L) ==>
%%% [a,c,b])

% math formula for squash 
% assuming S is a partial function whose domain
% is a subset of the integers
% squash(S) = T <=>
%   exists F:
%     F in [1,|S|] --> dom(S) & 
%     injective(F) & monotone(F) & 
%     T = F;S
% since F in [1,|S|] --> dom(S) & injective(F)
%       <=> F in [1,|S|] --> dom(S) & ran(F) = dom(S)
% then we have
% squash(S) = T <=>
%   exists F:
%     F in [1,|S|] --> dom(S) & ran(F) = dom(S) & 
%     monotone(F) & T = F;S
% and monotone(F)
%     <=> forall x1,x2 in dom(F): x1 < x2 ==> F(x1) < F(x2)
% which is equivalent to (F is a function)
%         forall (x1,y1),(x2,y2) in F: x1 < x2 ==> y1 < y2
% which in turn is equivalent to
%         F*F = {((x1,y1),(x2,y2)) in F*F | x1 < x2 ==> y1 < y2}
% then the final formula is
% squash(S) = T <=>
%   exists F:
%     F in [1,|S|] --> dom(S) & ran(F) = dom(S) & 
%     F*F = {((x1,y1),(x2,y2)) in F*F | x1 < x2 ==> y1 < y2} &
%     T = F;S
% then the {log} formula for squash is
% squash(S,T) :-
%   pfun(S) &
%   size(S,N) &
%   dom(S,DS)
%   pfun(F) & dom(F,DF) & subset(DF,int(1,N)) & size(DF,N) &
%   ran(F,DS) &
%   subset(cp(F,F),
%          ris([[X1,Y1],[X2,Y2] in cp(F,F), X1 >= X2 or Y1 < Y2)) &
%   comp(F,S,T)
%
% Another possible {log} formula for squash would be if RIS would allow
% for some RIS formulas as filters (see Section 10, last item, TOPLAS paper)
%
% squash(S,T) :-
%   pfun(S) &
%   size(S,N) &
%   dom(S,DS)
%   pfun(F) & dom(F,DF) & subset(DF,int(1,N)) & size(DF,N) &
%   ran(F,DS) &
%   subset(F,
%          ris([X1,Y1] in F, 
%              subset(F,ris([X2,Y2] in F,X1 >= X2 or Y1 < Y2)))) &
%   comp(F,S,T)


% a recursive implementation of squash
squash({},{}).
squash({X/Rel},{Y/List}) :- 
   X nin Rel & Y nin List &
   pfun({X/Rel}) &
   dom({X/Rel},D) & 
   set_to_list(D,LD) & 
   prolog_call(sort(LD,SLD)) & 
   squash0({X/Rel},SLD,1,{Y/List}).

squash0(_,[],_,{}).
squash0(Rel,[N|List],1,LSet) :-
   integer(N) &
   [N,X] in Rel &
   LSet = {[1,X] / L} & [1,X] nin L &
   squash0(Rel,List,2,L).
squash0(Rel,[N|List],K,LSet) :-
   integer(N) &
   [N,X] in Rel &
   LSet = {[K,X] / L} & [1,X] nin L &
   K1 is K + 1 &
   squash0(Rel,List,K1,L).


% Auxiliary predicates

% set_to_list(S,L): true if S is a set and L is 
% a list containing all and only the elements of S, 
% WITHOUT REPETITIONS
set_to_list({},[]).          
set_to_list({X/Set},List) :- 
   X nin Set &
   List = [X|L] & 
   set_to_list(Set,L).


